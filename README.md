## 个人见解

> 代码的设计本质上就是两个部分
> 1.职责划分
> 2.模块通信
>
> 好的设计应该是
>
> 1. 各单位模块职责清晰(包,接口,类,函数等);
> 2. 模块本身要可升级替换,有种可插拔的感觉;
> 3. 新代码要尽力而为遵守,老代码需要重构时按此原则重构;
> 4. SOLID原则比GOF23的定式重要;



## 单一职责(Single Responsibility)

> 命名时就应该想好职责,一个单元只做一件事.

## 开闭原则(Open Close)

> 只增不改

## 替换原则(Liskov Substitution)

>    模块通信问题,父类子类强制通信;所以使用继承操作时一般有规定;
>
> - 如果没有必要性,不要重写父类非抽象方法.
> - 子类的产生主要是为了新增自己的方法.
> - overload父类方法时,子类中的方法参数要更加宽松(@override当做重写是必备操作).对于入参,父类能接受子类一定也要能接受;这样替换成父类时,不会因为入参有影响;
> - 重写父类抽象法时,子类的返回值要更加严格,防止改变父类功能.对于执行的结果,子类要对结果更加负责,否则会导致没办法替换父类;
>
> 所谓继承,我的理解是这是一种强制通信,即子类一定要接受父类的某些行为(属性与方法).也就是常说的高耦合;当规定一个父类的所以子类都满足不重写父类已经实现类时,那么父类
> 的具体方法才得到完美的复用;
> 如果非要重写父类已经实现的方法的话,建议当前的父类和子类不要再有继承关系了,直接在搞个新的公共类,当做基类.

## 接口隔离(Interface Segregation)

> 接口就是用来描述行为定义规范的,如果一个类只需要实现了一个interface的部分方法就可以的话,那么这个接口的职责就不单一了,要重新考虑模块划分;不同于单一职责,接口定义的是抽象规范;单一职责是类的具体实现;
>
> 平时写代码,接口制定一定要细化,只暴露给他的实现类需要的方法.为实现而定制.

## 依赖倒置(Dependence Inversion)

> 接口也是一种强制通信,不过更像是强制复用;
> 对于功能的拓展点,使用接口在运行时确定代替编译时的if-else;这样就可以做到添加文件就可以增加拓展;
> 这个要求我们平时类里面的成员变量尽量是个接口.

## 迪米特法则(Law Of Demeter)

> - 类与类之间不要有太多的了解.
> - 当一个类要依赖另外一个类时,被依赖的类封装好实现逻辑,只提供public接口,被依赖的类不要作为方法的局部变量出现.
> - 类与类之间的调用最好有个管理者(facade,adapter,media,proxy);



## 总结

> 这就是设计模式的SOLID原则,最后,并不是要一定完全遵守这6个规则,为了规则而去定框架接口,有些业务做起来就很麻烦,所以要以业务需求为重心,尽量在这些原则上组织结构.不要本末倒置.
> 设计模式的最重要目标就是预测业务变化,在拓展点增加接口,减少代码修改
