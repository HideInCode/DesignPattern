## 开闭原则(Open Close)

------

​	开闭原则可能是设计模式六项原则中定义最模糊的一个了,它只告诉我们对扩展开放,对修改关闭,可是到底如何才能做到对扩展开放,对修改关闭,并没有明确的告诉我们.以前,如果有人告诉我"你进行设计的时候一定要遵守开闭原则",我会觉的他什么都没说,但貌似又什么都说了.因为开闭原则真的太虚了.
​	其实,我们遵循设计模式其他5大原则,以及使用23种设计模式的目的就是遵循开闭原则.也就是说,只要我们对前面5项原则遵守的好了,设计出的软件自然是符合开闭原则的,这个开闭原则更像是前面五项原则遵守程度的"平均得分",前面5项原则遵守的好,平均分自然就高,说明软件设计开闭原则遵守的好;如果前面5项原则遵守的不好,则说明开闭原则遵守的不好.

------

## 单一职责(Single Respnsibility)

------

多有的模块化设计都应该遵循这个原则,就是说设计一个模块一做一件事,有新的特性要在建造一个模块,不要因为创建模块复杂,修改起来简单而选择修改.这样违反了开闭的总纲.

------

## 替换原则(Liskov Substitution)

------

- 如果没有必要性,不要重写父类非抽象方法.
- 子类的产生主要是为了新增自己的方法.
- overload父类方法时,子类中的方法参数要更加宽松(怕子类无意重写父类方法,所以平时重写要加@override).
- 重写父类抽象法时,子类的返回值要更加严格,防止改变父类功能.

这是针对继承的要求,继承说白了就是父类提供规范,然后子类按照规范实现.如果子类吓鸡儿重写父类的方法,那么多态发生时,或者子类又有子类时容易出问题.

如果非要重写父类方法的话,建议当前的父类和子类不要再有继承关系了,直接在搞个新的公共类,当做基类.

------

## 依赖倒置(Dependence Inversion)

------

如果有这样的问题,就是类A直接依赖类B,假如要将类A改为依赖类C,则必须通过修改类A的代码来达成.这种场景下,类A一般是高层模块,负责复杂的业务逻辑;类B和类C是低层模块,负责基本的原子操作;假如修改类A,会给程序带来不必要的风险.就是说A应该面向接口编程.

这个要求我们平时类里面的成员变量尽量是个接口.

------

## 接口隔离(Interface Segregation)

------

一个接口,如果有的类实现它时,只用实现其中的部分方法就满足目的,但是按规则又必须实现其他方法,只要将这些写方法置空.这样的接口就可以拆分为多个接口.为各个类建立专用的接口,不要搞个上帝接口,让他做所有的事情.和单一职责不同的是,他约束的是规范(抽象类),单一职责约束的是实现.

平时写代码,接口制定一定要细化,只暴露给他的实现类需要的方法.为实现而定制.接口隔离还有另外一种理解,就是接口之间不要相互调用最好有个专门的中间接口(facade,adapter,media,proxy)

------

## 迪米特法则(Law Of Demeter)

------

类与类之间不要有太多的了解.当一个类要依赖另外一个类时,被依赖的类封装好实现逻辑,只提供public接口.而且被依赖的类不要作为局部变量出现.

------

**最后,并不是要一定完全遵守这6个规则,为了规则而去定框架接口,有些业务做起来就很麻烦,所以要以业务需求为重心,尽量在这些原则上组织结构.不要本末倒置.设计模式的最重要目标就是预测业务变化,抽象变化,隔离变化与稳定(相对的)**





