## 理解

---
    代码的设计本质上就是两个部分
    1.模块划分
    2.模块通信
    
    好的设计应该是
    
        模块职责清晰(包,接口,类,函数等);
        模块间依赖,调用要有插座那种可插拔的感觉;即使有更多更好的实现也不会破坏性的创造;
        即使这样说,不写个几十万行代码也是感觉不到什么叫做可插拔吧;
        所以,要不断思考新代码怎么写,老代码怎么重构才能有这种设计的感觉;
        与其朗读背诵gof23,不如好好思考代码的扩展点,怎么写尽可能少的违背一下这些原则;
    
---

## 开闭原则(Open Close)

------
    模块通信;没有强制依赖具体模块才可能有所谓的低耦合;而开闭原则更像是其它几个原则的目的;用于检查其它几个原则有么有发挥作用;
    对修改关闭,对增加开放;修改就意味着重新测试,重新审核代码;因此最好的策略就是能够做到新增的代码要能通过新增类文件的方式来解决;但是这也是所有原则中最难做好,
    甚至是做到的原则.尽管如此,我们在设计时还是要第一步考虑拓展性,多可变点拓展;最后完成时,检查有没有做到开闭原则;
​	
------

## 单一职责(Single Respnsibility)

------

    模块划分的基本原则;

------

## 替换原则(Liskov Substitution)

------

   模块通信问题,父类子类强制通信;所以使用继承操作时一般有规定;
- 如果没有必要性,不要重写父类非抽象方法.
- 子类的产生主要是为了新增自己的方法.
- overload父类方法时,子类中的方法参数要更加宽松(@override当做重写是必备操作).对于入参,父类能接受子类一定也要能接受;这样替换成父类时,不会因为入参有影响;
- 重写父类抽象法时,子类的返回值要更加严格,防止改变父类功能.对于执行的结果,子类要对结果更加负责,否则会导致没办法替换父类;

所谓继承,我的理解是这是一种强制通信,即子类一定要接受父类的某些行为(属性与方法).也就是常说的高耦合;当规定一个父类的所以子类都满足不重写父类已经实现类时,那么父类
的具体方法才得到完美的复用;
如果非要重写父类已经实现的方法的话,建议当前的父类和子类不要再有继承关系了,直接在搞个新的公共类,当做基类.

------

## 依赖倒置(Dependence Inversion)

------
接口也是一种强制通信,不过更像是强制复用;
对于功能的拓展点,使用接口在运行时确定代替编译时的if-else;这样就可以做到添加文件就可以增加拓展;
这个要求我们平时类里面的成员变量尽量是个接口.

------

## 接口隔离(Interface Segregation)

------

接口就是用来描述行为定义规范的,如果一个类只需要实现了一个interface的部分方法就可以的话,那么这个接口的职责就不单一了;要重新考虑模块划分;不同于
单一职责,接口定义的是抽象规范;单一职责是类的具体实现;


平时写代码,接口制定一定要细化,只暴露给他的实现类需要的方法.为实现而定制.

------

## 迪米特法则(Law Of Demeter)

------

类与类之间不要有太多的了解.当一个类要依赖另外一个类时,被依赖的类封装好实现逻辑,只提供public接口.
而且被依赖的类不要作为方法的局部变量出现.
类与类之间的调用最好有个管理者(facade,adapter,media,proxy);
------

**最后,并不是要一定完全遵守这6个规则,为了规则而去定框架接口,有些业务做起来就很麻烦,所以要以业务需求为重心,尽量在这些原则上组织结构.不要本末倒置.
设计模式的最重要目标就是预测业务变化,在拓展点增加接口,减少代码修改**





